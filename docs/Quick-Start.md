Here's an extremely basic Reactor project to get you familiar with a few of the core functions and interface elements you'll need to know. This isn't meant to be an exhaustive tutorial, just an introduction.

## Making Your First ReactorSensor

When you first install Reactor, the only device you have is the master Reactor device, also referred to as the *plugin device*. This device is the ringmaster for an arbitrary number of *ReactorSensors*[^1] (abbreviated to RS), which are child devices you must first create. To create an RS, you just go into the control panel of the Reactor master device and click the "Add Sensor" button. Creating a "child" device on Vera causes a Luup reload, which will happen immediately, and your system will be busy for a few seconds. While that's going on, refresh your browser (CTRL-F5 for Chrome/Win, SHIFT-F5 for Firefox/Win, CMD+SHIFT+R for most Mac browsers).

## Conditions -- Deciding When Action Needs to be Taken

The core thing you will have to do with all ReactorSensors is set up *conditions*, which are the tests that the RS performs. This is done in the "Conditions" tab of an RS. Go into the RS you created above, and you'll see the tab there--click it. You'll see that you're in editing mode for a comment condition, which is the minimal default that a new RS starts with. You can change that, so choose "Service" from the menu that currently says "Comment". The "Service" condition is the test that looks at device states. You'll then see a menu that lists all of your devices. Choose a switch (preferably one conveniently near your computer, but it doesn't matter which/what it controls). Then choose the "Status" variable from the next menu (if there are multiple Status entries, choose the one that says "(SwitchPower1)" after it).

> Sidebar: Luup/Vera uses a model of *services*, derived from UPnP. A service is a collection of behaviors and states that a device can have. Light switches, for example, would be expected to implement the "SwitchPower1" service. The service defines *actions* and *states*; actions are things the device can do, like turn on or turn off, and states are properties of the device, like whether it is current on or off. States are stored in *state variables*, and these are the things listed in that menu where you chose "Status" above. So, the hardest part about learning automation with Vera, is that you have to learn which service and state variable your condition lives in. For a switch, the on/off state lives in the SwitchPower1 service's `Status` state variable. A device can have multiple services. For example, a simple on/off switch might only implement the SwitchPower1 service, but a dimmer implements both SwitchPower1 and Dimming1--the former tells you it can be turned on and off like a simple switch, but the latter tells you that you can also set brightness. You'll get to know these services over time. Although there are A LOT of them, only a handful of state variables in a handful of services are actually relevant for most of what you'll need to do.

The last thing we want to do with our first switch condition is decide about the state of the switch, so to make life interesting, let's just say we want to know when the switch is *off*. Next to the menu now showing the selected "Status" variable, you'll see a menu of operations... choose "is FALSE" (you could also choose the "equals" operator and enter "0" as the operand in this case). That completes the editing for now, so click the "Save" button.

## Status Tab -- The Dashboard of Your ReactorSensor

Now, click the "Status" tab title to go back to the status display. You should see now that your RS is showing you your switch condition. If your switch is currently off, the condition will be highlighted with bold green text, indicating that the condition has been met. If you walk over to that switch and turn it on, you should shortly see that the condition display goes to black[^2]. Since we set up the test with an "is FALSE", the condition is met (true) whenever the switch is off, and not met when the switch is on (i.e. the condition state is the reverse of the switch state).

## Activities -- Turning Decisions into Actions

Now you want to do something with that information, so head over to the "Activities" tab in your RS. This looks a bit like the Conditions tab/editor, but this is where you specify actions that your RS needs to perform. You'll see two empty activity groups: *Tripped* and *Untripped*. The tripped activities are performed when your RS conditions are met. Your untripped activities are performed when your RS conditions are later unmet. We'll leave creating actual actions up to your discovery.

When is the RS tripped and untripped? Something I ignored above is that you were configuring that condition in a *group*. A group is simply a collection of conditions. In order for a group to be *true*, *all* of the conditions within the group have to be *true*; if *any* of them is *false*, the entire group will also be *false*. This is a logical AND. An RS can have more than one group. If *any* group in the RS is *true*, the entire RS is *tripped*. If no groups are *true*, the RS is *untripped*. This is a logical OR. 

In the simplest case, you will have one group, as you do in this example, and when all conditions in that group are met, the RS will be tripped and perform the tripped activities. When one or more of the conditions is later not met for whatever reason, the RS will untrip and the untripped activities will be performed.

Before you venture into deeper learning, the last thing you need to know is that Reactor only runs activities *once per state change*. To illustrate what this means, let's say you have an RS with just one condition that looks at a temperature sensor and tests to see if the current temperature is greater than or equal to 25C. When the temperature sensor reports 24C, the condition is not met, so it is false, and since it's the only condition in the only group, the RS will be untripped. When the temperature climbs to 25C, the condition is then met, so the group becomes true and the RS becomes tripped, so the tripped activities are then run. Then a short time later, the temperature climbs and the sensor reports 26C. At this point, the condition was already met at 25C--it's *true* and it can't get more true (true/false is binary--it is or it isn't--unlike politics, there are no degrees of true and false, no grey areas between). So, since the condition is already true, and the group true, and thus the RS is already in tripped state, the tripped activities *are not* run again. Activities only run when state *changes*.

---
[^1] Historical note: ReactorSensors are called that because they implement the *SecuritySensor1* service, which is to say, they implement the actions and states of a security sensor, like a door or motion sensor. The first versions of Reactor used Vera scenes to perform actions, and since scenes can be triggered by security sensors natively, having Reactor implement this behavior made it easy to trigger the necessary scenes. As of version 2.0, however, Reactor has its own *Activities*, which offer more features than Vera scenes. The terms *tripped* and *untripped* are used to describe the state of ReactorSensors because these are the states a security sensor can have (i.e. a motion sensor that detects motion, or a door sensor on an open door, is said to be tripped). Although Activities can replace scenes, you can still use scenes with Reactor if you wish, even in combination with Activities. Sometimes scenes are handy, because you want access to them in the UI. For example, if you have a set of actions that need to be performed by several different subsystems and/or from the UI, a scene may be a good choice, as it can be used like a subroutine.

[^2] Instantaneous response to a manual press/change of a switch requires that the device implement some form of "instant status." Not all devices do. If your RS status doesn't change immediately when you're manipulating your switch by hand, try changing the switch state via the Vera UI. If the RS condition then updates immediately, your switch doesn't support instant status.
